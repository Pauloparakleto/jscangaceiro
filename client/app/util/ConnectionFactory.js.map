{"version":3,"sources":["../../app-src/util/ConnectionFactory.js"],"names":["ConnectionFactory","stores","connection","close","constructor","Error","getConnection","Promise","resolve","reject","openRequest","indexedDB","open","onupgradeneeded","e","console","log","_createStores","target","result","onsuccess","bind","onerror","error","name","forEach","store","objectStoreNames","contains","deleteObjectStore","createObjectStore","autoIncrement","closeConnection"],"mappings":";;;;;;AAAO,YAAMA,oBAAoB,CAAE,MAAM;;AAEvC,cAAMC,SAAS,CAAC,cAAD,CAAf;AACA,YAAIC,aAAa,IAAjB;AACA,YAAIC,QAAQ,IAAZ;;AAEA,eAAO,MAAMH,iBAAN,CAAwB;AAC7BI,wBAAa;AACX,kBAAM,IAAIC,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAED,iBAAOC,aAAP,GAAuB;AACrB,mBAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,kBAAIP,UAAJ,EAAgB;AACd,uBAAOM,QAAQN,UAAR,CAAP;AACD;;AAED,oBAAMQ,cAAcC,UAAUC,IAAV,CAAe,YAAf,EAA6B,CAA7B,CAApB;AACAF,0BAAYG,eAAZ,GAA8BC,KAAK;AACjCC,wBAAQC,GAAR,CAAY,uBAAZ;AACAhB,kCAAkBiB,aAAlB,CAAgCH,EAAEI,MAAF,CAASC,MAAzC;AACD,eAHD;;AAKAT,0BAAYU,SAAZ,GAAwBN,KAAK;AAC3BZ,6BAAaY,EAAEI,MAAF,CAASC,MAAtB;AACAhB,wBAAQD,WAAWC,KAAX,CAAiBkB,IAAjB,CAAsBnB,UAAtB,CAAR;AACAA,2BAAWC,KAAX,GAAmB,MAAM;AACvB,wBAAM,IAAIE,KAAJ,CAAU,4CAAV,CAAN;AACD,iBAFD;AAGAG,wBAAQM,EAAEI,MAAF,CAASC,MAAjB;AACD,eAPD;;AASAT,0BAAYY,OAAZ,GAAsBR,KAAK;AACzBC,wBAAQC,GAAR,CAAYF,EAAEI,MAAF,CAASK,KAArB;AACAd,uBAAOK,EAAEI,MAAF,CAASK,KAAT,CAAeC,IAAtB;AACD,eAHD;AAID,aAxBM,CAAP;AAyBD;;AAED,iBAAOP,aAAP,CAAqBf,UAArB,EAAiC;AAC/BD,mBAAOwB,OAAP,CAAeC,SAAS;AACtB,kBAAIxB,WAAWyB,gBAAX,CAA4BC,QAA5B,CAAqCF,KAArC,CAAJ,EAAiD;AAC7CxB,2BAAW2B,iBAAX,CAA6BH,KAA7B;AACH;;AAEDxB,yBAAW4B,iBAAX,CAA6BJ,KAA7B,EAAoC,EAAEK,eAAe,IAAjB,EAApC;AACD,aAND;AAOD;;AAED,iBAAOC,eAAP,GAAwB;AACtB,gBAAI9B,UAAJ,EAAgBC;AACjB;AA7C4B,SAA/B;AA+CD,OArDgC,GAA1B","file":"ConnectionFactory.js","sourcesContent":["export const ConnectionFactory = ( () => {\n\n  const stores = ['negotiations'];\n  let connection = null;\n  let close = null;\n\n  return class ConnectionFactory {\n    constructor(){\n      throw new Error('Singleton class');\n    }\n\n    static getConnection() {\n      return new Promise((resolve, reject) => {\n        if (connection) {\n          return resolve(connection);\n        }\n\n        const openRequest = indexedDB.open('cangaceiro', 6);\n        openRequest.onupgradeneeded = e => {\n          console.log('creating negotiations');\n          ConnectionFactory._createStores(e.target.result);\n        };\n\n        openRequest.onsuccess = e => {\n          connection = e.target.result;\n          close = connection.close.bind(connection);\n          connection.close = () => {\n            throw new Error('This connection can not be closed directly');\n          }\n          resolve(e.target.result);\n        };\n\n        openRequest.onerror = e => {\n          console.log(e.target.error)\n          reject(e.target.error.name);\n        };\n      });\n    }\n\n    static _createStores(connection) {\n      stores.forEach(store => {\n        if (connection.objectStoreNames.contains(store)) {\n            connection.deleteObjectStore(store);\n        }\n\n        connection.createObjectStore(store, { autoIncrement: true })\n      });\n    }\n\n    static closeConnection(){\n      if (connection) close()\n    }\n  }\n})();\n"]}